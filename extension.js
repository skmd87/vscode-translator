// The module 'vscode' contains the VS Code extensibility API
// Import the module and reference it with the alias vscode in your code below
const vscode = require('vscode');
const axios = require('axios');
const https = require('https');
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
// This method is called when your extension is activated
// Your extension is activated the very first time the command is executed

/**
 * @param {vscode.ExtensionContext} context
 */

const yellowBackground = vscode.window.createTextEditorDecorationType({
	backgroundColor: 'yellow',
	color: 'black'
});


function activate(context) {

	// Use the console to output diagnostic information (console.log) and errors (console.error)
	// This line of code will only be executed once when your extension is activated
	console.log('Congratulations, your extension "translator" is now active!');





	let editor = vscode.window.activeTextEditor;
	if (editor) {
		highlightMatches(editor.document);
	}

	let disposable1 = vscode.workspace.onDidChangeTextDocument(event => {
		let document = event.document;
		highlightMatches(document);
	});
	let disposable2 = vscode.workspace.onDidOpenTextDocument(event => {
		let document = event;
		highlightMatches(document);
	});
	context.subscriptions.push(disposable1, disposable2);




	const api = axios.create({
		httpsAgent: new https.Agent({
			rejectUnauthorized: false
		})
	});
	// The command has been defined in the package.json file
	// Now provide the implementation of the command with  registerCommand
	// The commandId parameter must match the command field in package.json
	let disposable = vscode.commands.registerCommand('translator.new', async function () {

		// The code you place here will be executed every time your command is executed

		const config = vscode.workspace.getConfiguration('translator');


		var editor = vscode.window.activeTextEditor;
		if (!editor) {
			return; // No open text editor
		}

		var selection = editor.selection;
		var input = editor.document.getText(selection);

		var group, key, translation, isAutoGenerated = false;

		//if the selection matches wordOrDash.wordOrDash
		if (isValidGroupKey(input)) {
			//then split by dot. the first index is the group and the second is the key
			[group, key] = input.split('.');
			translation = null;

		} else {
			translation = input;
			group = generateGroup();
			key = generateKey(translation);
			isAutoGenerated = true;
		}

		if (!translation) {
			translation = await vscode.window.showInputBox({
				placeHolder: 'Enter translation',
				validateInput: text => {
					if (text.length === 0) {
						return 'Translation cannot be empty';
					}
					return null;
				}
			});
		}

		if (isAutoGenerated) {
			// show input for group.key 
			const newGroupKey = await vscode.window.showInputBox({
				placeHolder: 'Enter group.key',
				value: `${group}.${key}`,
				title: 'is the auto generated key correct?',
				validateInput: text => {
					if (text.length === 0) {
						return 'Translation cannot be empty';
					}

					if (!isValidGroupKey(text)) {
						return 'Invalid group.key';
					}

					return null;
				}
			});

			[group, key] = newGroupKey.split('.');
		}

		const body = {
			group,
			key,
			"exception": null,
			"languages": [

				{
					"language_id": 2,
					"abbreviation": "en",
					"direction": "ltr",
					"value": translation
				},

			],
			"type": "text",
			"tags": [],
			"placeholders": [],
			"is_published": true,
		}


		//get the url from the settings

		//read data from settings
		// if token not set then try to take from the settings, if not available then prompt for username and password
		// if token is set then use it
		// if token is expired then delete the token and generate one and set it in the settings
		// if token is not expired then use it


		let loginURL = config.get('loginURL');
		let createURL = config.get('createURL');
		let username = config.get('username');
		let token = config.get('token');
		let password = config.get('password');

		if (!loginURL) {
			// show input for url
			loginURL = await vscode.window.showInputBox({
				placeHolder: 'Enter Login URL',
				validateInput: text => {
					if (text.length === 0) {
						return 'URL cannot be empty';
					}
					return null;
				}
			});
			config.update('loginURL', loginURL, true);

		}


		if (!token) {
			if (!username) {
				username = await vscode.window.showInputBox({
					placeHolder: 'Enter username',
					validateInput: text => {
						if (text.length === 0) {
							return 'Username cannot be empty';
						}
						return null;
					}
				});
			}
			if (!password) {
				password = await vscode.window.showInputBox({
					placeHolder: 'Enter password',
					validateInput: text => {
						if (text.length === 0) {
							return 'Password cannot be empty';
						}
						return null;
					}
				});
			}
			console.log('sending', {
				email: username,
				password
			})
			await api.post(loginURL,
				{
					email: username,
					password
				},
				{
					headers: {
						'Content-Type': 'application/json',
						'Accept': 'application/json',
						'Entity': 'www.ingotbrokers.com',
						'Language': 'en'
					}
				}
			).then((response) => {
				console.log(response);
				vscode.window.showInformationMessage("Login successful");
				console.log('token', response)
				token = response.data.token.access_token;
				config.update('token', response.data.token.access_token, true);
				config.update('username', username, true);
				config.update('password', password, true);
			}).catch((error) => {
				console.log(error);
				vscode.window.showInformationMessage("Error logging in");
			});

		}

		if (!createURL) {
			// show input for url
			createURL = await vscode.window.showInputBox({
				placeHolder: 'Enter Create URL',
				validateInput: text => {
					if (text.length === 0) {
						return 'URL cannot be empty';
					}
					return null;
				}
			});
			config.update('createURL', createURL, true);
			return;
		}



		await api.post(createURL, body, {
			headers: {
				'Authorization': `Bearer ${token}`,
				'Content-Type': 'application/json',
				'Accept': 'application/json',
				'Entity': 'www.ingotbrokers.com',
				'Language': 'en'
			},
		}).then((response) => {
			console.log(response);
			// replace the selection with the group.key
			editor.edit(editBuilder => {
				editBuilder.replace(selection, `${group}.${key}`);
			});
			vscode.window.showInformationMessage("Translation added successfully");
		}).catch((error) => {
			console.log(error);
			vscode.window.showInformationMessage("Error adding translation");
		});






	});

	context.subscriptions.push(disposable);
}

function highlightMatches(document) {
	let editor = vscode.window.activeTextEditor;
	if (editor && editor.document === document) {
		let regex = /\$t\(([`'"])(.*?)\1\)/g;
		let text = document.getText();
		let match;
		let decorations = [];
		while (match = regex.exec(text)) {
			let startPos = document.positionAt(match.index + 4); // start after "$t("
			let endPos = document.positionAt(match.index + match[0].length - 1); // end before the closing parenthesis
			let matchedText = match[2];
			let decoration = {
				range: new vscode.Range(startPos, endPos),
				hoverMessage: createTooltip(matchedText),
				color: 'black',
				backgroundColor: 'yellow',
				fontWeight: 'bold',
				fontStyle: 'italic'
			};
			decorations.push(decoration);
		}
		editor.setDecorations(yellowBackground, decorations);
	}
}

function createTooltip(originalText) {
	return `Original Text: ${originalText}`;
}

function generateGroup() {
	//GENERATE GROUP NAME BY TAKING THE FILE NAME AND REMOVING THE EXTENSION AND CONVERT IT TO KEBAB CASE
	var editor = vscode.window.activeTextEditor;
	if (!editor) {
		return; // No open text editor
	}
	var fileName = editor.document.fileName;
	// remove the path (windows, mac and linux) and file extension and then convert it to kebab case
	var group = fileName.replace(/^.*[\\\/]/, '').replace(/\.[^/.]+$/, '').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	return group;
}

function generateKey(word) {
	//GENERATE KEY BY TAKING THE SELECTED TEXT AND CONVERTING IT TO kebab CASE and trim it to 12 characters or less by ending it on the dash
	var key = word.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
	if (key.length > 12) {
		key = key.substring(0, key.lastIndexOf('-'));
	}
	return key;
}


function isValidGroupKey(input) {
	return input.match(/^[a-zA-Z0-9]+(\.[a-zA-Z0-9]+)+$/)
}

// This method is called when your extension is deactivated
function deactivate() {

	yellowBackground.dispose();
}

module.exports = {
	activate,
	deactivate
}
